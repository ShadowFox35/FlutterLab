# 2. Algorithm Task - Longest Increasing Subsequence

Description of the task is available at the link https://leetcode.com/problems/longest-increasing-subsequence/description/

## Solution explanation

Решение данной задачи похоже не предыдущую по своей сути. В значения элементов созданного списка будем сохранять длину возрастающей последовательности, а его индекс будет равен индексу элемента в списке nums, до которого (включительно) была рассчитана длина последовательности.

Например входящий список nums = [2,8,3,10,13], а список incrSeq = [1,2,2,3,4].  
До элемента nums[0]=2 размер возрастающей последовательности равен incrSeq[0]=1; (т.е только сам элемент 2)  
До элемента nums[1]=8 размер возрастающей последовательности равен incrSeq[1]=2; (т.е элементы 2,8)  
До элемента nums[2]=3 размер возрастающей последовательности равен incrSeq[2]=2; (т.е элементы 2,3)  
До элемента nums[3]=10 размер возрастающей последовательности равен incrSeq[3]=3; (т.е элементы 2,3,10 и 2,8,10)  
До элемента nums[4]=13 размер возрастающей последовательности равен incrSeq[4]=4; (т.е элементы 2,3,10,13 и 2,8,10,13)  

### Описание каждой строки решения, начиная с 3

3. **_List<int> incrSeq = List.filled(nums.length, 1)_** - создаем список такого же размера, как получаемый. Начальное значение каждого элемента будет равно 1, т.е размер возрастающей последовательности до рассматриваемого элемента по умолчанию включает только 1 элемент (т.е. его самого).  
4. **_for (int i = 1; i < nums.length; i++)_** - цикл для прохода по приходящему списку, где i - текущий элемент. Начинаем с первого элемента (i=1), т.к в нулевом не может быть никакая другая длина последовательности, кроме 1, и его нет смысла рассматривать.  
5. **_for (int j = 0; j < i; j++)_** - цикла для прохода по тому же списку,но рассматриваем элементы, предшествующие i, чтобы иметь возможность их сравнивать. Поэтому ставим ограничение j < i, чтобы цикл брал только предшествующие элементы и не шел дальше. Здесь важно, что мы рассматриваем все предшествующие элементы, а не только один предыдущий, т.к возрастающая последовательность не обязательно состоит из чисел, идущих подряд.  
6. **_if (nums[i] > nums[j] && incrSeq[j] + 1 > incrSeq[i])_** - проверка последовательности на возрастание. Если текущий элемент списка nums больше предыдущего и размер последовательности, записанный в incrSeq в предыдущем элемента + 1 (т.е + текущий элемент списка nums) больше чем текущий.  
7. **_incrSeq[i] = incrSeq[j] + 1_** - если условие выше справедливо, то можем записать в текущий элемент новый размер последовательности, равный размеру последовательности, записанной в предыдущем элементе + 1 (т.е + текущий элемент)  
8. **_incrSeq.sort()_** - отсортируем список с размером полученных последовательностей по возрастанию.  
9. **_incrSeq[nums.length-1]_** - понятно, что последний элемент отсортированного списка представляет собой самую длинную найденную возрастающую последовательность.  

   **_И снова советуем рассмотреть произвольный список чисел и пройтись по каждой итерации каждого цикла._**
