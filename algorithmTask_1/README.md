# 1. Algorithm Task - Coin Change

Description of the task is available at the link https://leetcode.com/problems/coin-change/description/

## Solution explanation

Суть решения в том, чтобы создать список с количеством элементов amount+1, где значение элемента будет означать минимальное кол-во монет, которое потребуется для получении суммы, равной индексу элемента.

Например, имеем список [0,1,1,2,2,3].
0 - количество монет для получения суммы 0,  
1 - количество монет для получения суммы 1,  
1 - количество монет для получения суммы 2,  
2 - количество монет для получения суммы 3,  
2 - количество монет для получения суммы 4,  
3 - количество монет для получения суммы 5 и т.д.

Таким образом, обратившись к элементу с индексом **_amount_**, можно получить значение минимального кол-ва монет для получения заданной суммы **_amount_**.

Запись значение кадого последующего элемента происходит с использованием значения предыдущего + 1 (1 - это одна текущая рассматриваемая в цикле **_for in_** монетка)

### Описание каждой строки решения, начиная с 3

3. **_if (amount == 0) return 0;_** - если нужна нулевая сумма, то и монет для нее нужно 0 и нет смысла выполнять код дальше.
4. **_coins.sort();_** - сортировка массива монет по возрастанию обеспечивает обработку монет в порядке возрастания и позволит далее прекращать итерацию, если текущая монета больше рассматриваемой суммы. Таким образом мы будем избегать лишних итераций.
5. **_List<int> resCounts = List.filled(amount + 1, -1);_** - создаем список **_resCounts_** и заполняем его элементами **_-1_** в количестве **_amount + 1_**.  
   **_resCounts_** будет использоваться для хранения минимального количества монет, необходимого для достижения каждой суммы от **_0_** до **_amount_** . Использование начального значения **_-1_** означает, что количество монет для данной суммы еще не было рассчитано или невозможно достичь. Значение элемента списка - минимальное количество монет, а его индекс - сумма, которую можно получить.
6. **_resCounts[0] = 0;_** - запишем начальное значение **_0_** монет для суммы **_0_**.

7. **_for (int i = 1; i <= amount; i++)_** - создаем цикл для прохода по списку **_resCounts_**, где кол-во итераций **_i_** - искомая сумма (amount).
8. **_for (int coin in coins)_** - цикла для перебора имеющихся монет в списке **_coins_**.
9. **_if (coin > i) break;_** - как только мы переходим к монете номиналом больше искомой суммы **_i_**, то логично, что с она нам не подходит и последующие монеты тоже, тк массив **_coins_** отсортирован по возрастанию, а значит, можно завершить цикл перебора монет и перейти к следующей итерации внешнего цикла.
10. **_if (resCounts[i - coin] != -1)_** - отнимаем от искомой суммы проверяемую монетку и проверяем, было ли посчитано количество монет для получения остатка, т.к возможно ли получить остаток, рассматривая данную монету.

Например, имеем список монет [2,3].  
Пытаемся получить сумму (i)=4, рассматриваем монетку с наминалом 3. 4-3=1, обращаемся к элементу массива resCounts с индексом 1 (помним, что индекс элемента - искомая сумма) и понимаем, что если в значении элемента с индексом 1 записано какое-то значение, то значит ранее оно было посчитано и его возможно получить, используя рассматриваемую монетку 3. Если занчение элемента resCounts[1]=-1, значит ранее это значение не было посчитано, тк его невозможно достичь, если мы будем использовать монетку 3.

11. **_if (resCounts[i] == -1 || resCounts[i - coin] + 1 < resCounts[i])_** - если для суммы i не определено количество монет (1-е условие) или если оно не минимальное(т.е если к остатку i - coin прибавить еще одну монетку (текущую), то это больше кол-ва монет, рассчитанных ранее с использованием предыдущих монет).
12. **_resCounts[i] = resCounts[i - coin] + 1_** - записываем в значение для элемента resCounts[i] количество монет, равное оптимальному кол-ву монет для остатка + текущая рассматриваемая монетка.

**_Решение становится понятнее, если рассмотреть произвольный массив монет с произвольной суммой и пройтись по каждой итерации каждого цикла._**
