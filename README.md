# 1. Algorithm Task - Coin Change

Description of the task is available at the link https://leetcode.com/problems/coin-change/description/

## Solution explanation

Суть решения в том, чтобы создать список с количеством элементов amount+1, где значение элемента будет означать минимальное кол-во монет, которое потребуется для получении суммы, равной индексу элемента.

Например, имеем список [0,1,1,2,2,3].
0 - количество монет для получения суммы 0,
1 - количество монет для получения суммы 1,
1 - количество монет для получения суммы 2,
2 - количество монет для получения суммы 3,
2 - количество монет для получения суммы 4,
3 - количество монет для получения суммы 5 и т.д.

Таким образом, обратившись к элементу с индексом **_amount_**, можно получить значение минимального кол-ва монет для получения заданной суммы **_amount_**.

Запись значение кадого последующего элемента происходит с использованием значения предыдущего + 1 (1 - это одна текущая рассматриваемая в цикле **_for in_** монетка)

### Описание каждой строки решения, начиная с 3

3. **_if (amount == 0) return 0;_** - если нужна нулевая сумма, то и монет для нее нужно 0 и нет смысла выполнять код дальше.
4. **_coins.sort();_** - сортировка массива монет по возрастанию обеспечивает обработку монет в порядке возрастания и позволит далее прекращать итерацию, если текущая монета больше рассматриваемой суммы. Таким образом мы будем избегать лишних итераций.
5. **_List<int> resCounts = List.filled(amount + 1, -1);_** - создаем список **_resCounts_** и заполняем его элементами **_-1_** в количестве **_amount + 1_**.
   **_resCounts_** будет использоваться для хранения минимального количества монет, необходимого для достижения каждой суммы от **_0_** до **_amount_** . Использование начального значения **_-1_** означает, что количество монет для данной суммы еще не было рассчитано или невозможно достичь. Значение элемента списка - минимальное количество монет, а его индекс - сумма, которую можно получить.
6. **_resCounts[0] = 0;_** - запишем начальное значение **_0_** монет для суммы **_0_**.

7. **_for (int i = 1; i <= amount; i++)_** - создаем цикл для прохода по списку **_resCounts_**, где кол-во итераций **_i_** - искомая сумма (amount).
8. **_for (int coin in coins)_** - цикла для перебора имеющихся монет в списке **_coins_**.
9. **_if (coin > i) break;_** - как только мы переходим к монете номиналом больше искомой суммы **_i_**, то логично, что с она нам не подходит и последующие монеты тоже, тк массив **_coins_** отсортирован по возрастанию, а значит, можно завершить цикл перебора монет и перейти к следующей итерации внешнего цикла.
10. **_if (resCounts[i - coin] != -1)_** - отнимаем от искомой суммы проверяемую монетку и проверяем, было ли посчитано количество монет для получения остатка, т.к возможно ли получить остаток, рассматривая данную монету.

Например, имеем список монет [2,3].
Пытаемся получить сумму (i)=4, рассматриваем монетку с наминалом 3. 4-3=1, обращаемся к элементу массива resCounts с индексом 1 (помним, что индекс элемента - искомая сумма) и понимаем, что если в значении элемента с индексом 1 записано какое-то значение, то значит ранее оно было посчитано и его возможно получить, используя рассматриваемую монетку 3. Если занчение элемента resCounts[1]=-1, значит ранее это значение не было посчитано, тк его невозможно достичь, если мы будем использовать монетку 3.

11. **_if (resCounts[i] == -1 || resCounts[i - coin] + 1 < resCounts[i])_** - если для суммы i не определено количество монет (1-е условие) или если оно не минимальное(т.е если к остатку i - coin прибавить еще одну монетку (текущую), то это больше кол-ва монет, рассчитанных ранее с использованием предыдущих монет).
12. **_resCounts[i] = resCounts[i - coin] + 1_** - записываем в значение для элемента resCounts[i] количество монет, равное оптимальному кол-ву монет для остатка + текущая рассматриваемая монетка.

**_Решение становится понятнее, если рассмотреть произвольный массив монет с произвольной суммой и пройтись по каждой итерации каждого цикла._**

# 2. Algorithm Task - Longest Increasing Subsequence

Description of the task is available at the link https://leetcode.com/problems/longest-increasing-subsequence/description/

## Solution explanation

Решение данной задачи похоже не предыдущую по своей сути. В значения элементов созданного списка будем сохранять длину возрастающей последовательности, а его индекс будет равен индексу элемента в списке nums, до которого (включительно) была рассчитана длина последовательности.

Например входящий список nums = [2,8,3,10,13], а список incrSeq = [1,2,2,3,4].
До элемента nums[0]=2 размер возрастающей последовательности равен incrSeq[0]=1; (т.е только сам элемент 2)
До элемента nums[1]=8 размер возрастающей последовательности равен incrSeq[1]=2; (т.е элементы 2,8)
До элемента nums[2]=3 размер возрастающей последовательности равен incrSeq[2]=2; (т.е элементы 2,3)
До элемента nums[3]=10 размер возрастающей последовательности равен incrSeq[3]=3; (т.е элементы 2,3,10 и 2,8,10)
До элемента nums[4]=13 размер возрастающей последовательности равен incrSeq[4]=4; (т.е элементы 2,3,10,13 и 2,8,10,13)

### Описание каждой строки решения, начиная с 3

3. **_List<int> incrSeq = List.filled(nums.length, 1)_** - создаем список такого же размера, как получаемый. Начальное значение каждого элемента будет равно 1, т.е размер возрастающей последовательности до рассматриваемого элемента по умолчанию включает только 1 элемент (т.е. его самого).
4. **_for (int i = 1; i < nums.length; i++)_** - цикл для прохода по приходящему списку, где i - текущий элемент. Начинаем с первого элемента (i=1), т.к в нулевом не может быть никакая другая длина последовательности, кроме 1, и его нет смысла рассматривать.
5. **_for (int j = 0; j < i; j++)_** - цикла для прохода по тому же списку,но рассматриваем элементы, предшествующие i, чтобы иметь возможность их сравнивать. Поэтому ставим ограничение j < i, чтобы цикл брал только предшествующие элементы и не шел дальше. Здесь важно, что мы рассматриваем все предшествующие элементы, а не только один предыдущий, т.к возрастающая последовательность не обязательно состоит из чисел, идущих подряд.
6. **_if (nums[i] > nums[j] && incrSeq[j] + 1 > incrSeq[i])_** - проверка последовательности на возрастание. Если текущий элемент списка nums больше предыдущего и размер последовательности, записанный в incrSeq в предыдущем элемента + 1 (т.е + текущий элемент списка nums) больше чем текущий.
7. **_incrSeq[i] = incrSeq[j] + 1_** - если условие выше справедливо, то можем записать в текущий элемент новый размер последовательности, равный размеру последовательности, записанной в предыдущем элементе + 1 (т.е + текущий элемент)
11. **_incrSeq.sort()_** - отсортируем список с размером полученных последовательностей по возрастанию.
12. **_incrSeq[nums.length-1]_** - понятно, что последний элемент отсортированного списка представляет собой самую длинную найденную возрастающую последовательность.

   **_И снова советуем рассмотреть произвольный список чисел и пройтись по каждой итерации каждого цикла._**
