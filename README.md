# 3. Algorithm Task - Course Schedule

Description of the task is available at the link https://leetcode.com/problems/course-schedule/description/

## Solution explanation

Для решения данной задачи будет полезно ввести понятие графа.
Граф - это структура, которая помогает наглядно продемонстрировать связи между различными элементами. Элементы называют вершинами, а связи между ними - ребрами.

Для решения данной задачи будем использовать алгоритм топологической сортировки для упорядочивания графа.

**_Общая схема решения задачи с использованием топологической сортировки_**

**_- Построение списка смежности:_** Для решения данной задачи будет построен список смежностей **_adjList_** , который будет отражать связи между курсами.
Список смежности - это структура данных, используемая в графах, чтобы представить связи между его вершинами.
Список смежностей представляет собой такой список, где каждой вершине графа список смежных вершин (т.е список, где каждому курсу соответствует список связанных с ним курсов = список списков).
В данном случае индекс элемента будет представлять собой номер курса, а значение элемента - список связанных с ним других курсов. Обратим внимание, что размер списка будет равен **_numCourses_**, что логично, тк **_numCourses_** представляет общее количество курсов.

Например:
количество курсов numCourses = 4
приходящий список зависимостей между курсами prerequisites = [[1,0],[1,2],[3,2],[1,3],[2,0]].

первое число - курс (далее elem[0])
второе - курс, который предварительно нужно закончить (далее elem[1]).

adjList = [[1, 2], [], [1, 3], [1]]
индекс - предварительный курс
значения в списке под индексом - возможные курсы, которые откроются при прохождении курса=index.

### Описание каждой строки решения, начиная с 3

**_Часть 1 - Инициализация_**
**_3.List<List<int>> adjList = List.generate(numCourses, (index) => [])_**- создаем список смежности **_adjacencyList_** из 4 элементов, каждый их которых - пустой список.
**_4. List<int> incEdges = List.filled(numCourses, 0)_** - создаем список incEdges размером **_numCourses_**, в котором будем подсчитывать количество входящих ребер для каждого курса. Исходно все значения списка равны нулю. Затем, при построении списка смежности, мы увеличиваем значение входящих ребер для каждого курса, на который имеется зависимость.

**_Часть 2 - цикл for elem in prerequisites, формирование adjList и incEdges_**
**_6. for (List<int> elem in prerequisites)_** - это цикл for-in, который итерируется по каждому элементу (внутреннему списку) в приходящем списке зависимостей **_prerequisites_**.
elem[0]; - значение первого элемента prerequisites (курс, который нужно пройти - курс ai).
elem[1]; - значение второго элемента prerequisites (необходимый курс, от которого зависит course - курс bi).
**_7. adjList[elem[1]].add(elem[0])_** - в данной строке мы добавляем course в список смежности для курса **_elem[1]_**. Это отражает зависимость курса course от курса **_elem[1]_**.
**_8. incEdges[elem[0]]++_** - списко **_incEdges_** будет содержать кол-во курсов, которые необходимо закончить для курса с номером = индексу. Пояснение будет дальше.

Для лучшего понимания можно рассматривать **_adjList_** как список возможностей, т.е в нем по будут возможные курсы, открытые после прохождения курса=index,
а **_incEdges_** как список необходимостей, т.е он содержит кол-во курсов, которые нужно пройти для получения доступа к курсу=index.

**_Часть 3 - формирование списка queue_**
**_11. List<int> queue = []_** - создаем пустой список **_queue_**, где будут храниться доступные курсы, которые можно пройти без зависимостей или курсы, для которых все зависимости уже выполнены.
**_12. for (int i = 0; i < numCourses; i++)_** - цикл, где i - текущий индекс курса, который мы проверяем.

Для добавления курса в **_queue_**, нужно проверить, является ли курс **i** доступным (закончены ли все необходимые курсы).
Для этого используем **_incEdges_**, в котором как раз записано кол-во необходимых курсов для прохождения курса **i**.

**_13. if (incEdges[i] == 0)_** - проверяем, есть ли у курса i зависимости.
**_14. queue.add(i)_**- Если зависимостей нет, то курс i может быть добавлен в список queue.

**_Часть 3.1 - заканчиваем доступные в queue курсы и засчитываем их в finishedCourses_**
**_18. int finishedCourses = 0_** - сюда будем записывать завершенные курсы. Начнем с 0 завершенных курсов.

**_20. while (queue.isNotEmpty)_**- цикл, который будет завершать курсы до тех пор, пока список доступных курсов queue не станет пустым.
**_21. int curCourse = queue.removeAt(0)_** - извлекаем курс из списка доступных **_(queue)_** с помощью метода removeAt(0) и сохраняем его в переменную **_curCourse_**. Это текущий курс, который мы завершаем.
**_22. finishedCourses++_** - увеличиваем количество завершенных курсов на 1.

**_Часть 3.2 - пополняем список доступных курсов queue, учитывая списки adjList и incEdges_**
**_24. for (int nextCourse in adjList[curCourse])_**- цикл для перебора (и переноса в queue) всех курсов в списке смежностей(возможностей), которые возможны при завершении **_curCourse_**, где nextCourse означает номер возможного курса.
**_25. incEdges[nextCourse]--_** - поскольку **_nextCourse_** возможет, уменьшаем количество курсов, которые нужно закончить для его прохождения.
**_26. if (incEdges[nextCourse] == 0)_** - проверяем, выполнены ли все курсы для курса nextCourse и можно ли считать курс **_nextCourse_** доступным.
**_27.queue.add(nextCourse)_** - если это так, мы добавляем его в список доступных курсов queue, чтобы он был обработан во внешнем цикле **_while_** и по итогу записан в **_finishedCourses_**.

**_Часть 4 - проверим, смогли ли мы завершить все предлагаемые по условию курсы_**
**_32.return finishedCourses == numCourses_** - вернет true, если все курсы были успешно завершены, то есть количество завершенных курсов равно общему количеству курсов.
